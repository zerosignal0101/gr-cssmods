id: cssmods_css_decode_symbols
label: CSS Decode Symbols
category: '[cssmods]'

templates:
  imports: from gnuradio import cssmods
  make: cssmods.css_decode_symbols(${sf}, ${bw}, ${zero_padding_ratio})

parameters:
-   id: sf
    label: Spreading Factor
    dtype: int
    default: 7
    options: [7, 8, 9, 10, 11, 12]
    option_labels: [SF7, SF8, SF9, SF10, SF11, SF12]
-   id: bw
    label: Bandwidth (Hz)
    dtype: real
    default: 125000.0
-   id: zero_padding_ratio
    label: Zero Padding Ratio
    dtype: int
    default: 4 # Common value, ensure it matches frame_sync
    # validator: gr.gr_validator.minimum(1) # if applicable

inputs:
-   label: in
    domain: stream
    dtype: complex
    # Optional: vlen: $sample_num (if you want to enforce it, but usually not needed for sync_block)

outputs:
-   label: out
    domain: stream
    dtype: byte

# Optional: Variables to expose derived parameters to GRC, if useful
# C++ code does this internally.
# variables:
# - id: sample_num
#   value: 2 * (1 << sf)

file_format: 1

documentation: |-
    Decodes LoRa CSS symbols from a complex input stream.

    This block expects 'payload_start' tags on its input. The dictionary associated with this tag MUST contain an integer item with the key "preamble_bin". This value is used as a phase and frequency reference for symbol demodulation.

    Each valid symbol sequence (d_sample_num complex samples) after a 'payload_start' tag is demodulated into a single byte representing the symbol value. Data not part of an active payload (i.e., before the first tag or if a tag is invalid) is consumed but does not produce output. A 'payload_start' tag is propagated to the output stream, aligned with the first byte of the corresponding payload.

